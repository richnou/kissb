package provide kiss 1.0
#package require TclCurl

namespace eval kiss {


    #####################
    ## Context
    #####################


    #####################
    ## Env variables
    #####################
    namespace eval env {

        #set _targets [dict create]

        proc ::env {name default} {
            if {[array names ::env -exact $name] == ""} {
                puts "Setting default for $name"
                #uplevel [list set env($name) $default]
                uplevel [list array set env [list $name $default]]
            }
            #return [uplevel [list set \$env($name)]]
            return [uplevel [array get env $name]]
        }

    }

    namespace eval vars {

        set _vars [dict create]

        proc append {name args} {
            dict lappend kiss::vars::_vars $name {*}$args
        }
        proc get {name {default {}}} {
            if {[dict exists $kiss::vars::_vars $name]} {
                return [dict get $kiss::vars::_vars $name]
            } else {
                return $default
            }
            
        }

    }

    #############################
    ## Targets
    #############################
    proc ::@ {name args} {
        kiss::targets::@ $name {*}$args
    }
    namespace eval targets {

        set _targets [dict create]

        proc @ {name args} {
            log.info "Registering target $name, size of args=[llength $args]"
            set script [lindex $args end]
            #log.info "Script is: $script"
            set reqTargets {}
            if {[llength $args]>1} {
                set requiredTargets [lrange $args 0 end-1]
                foreach requiredTarget $requiredTargets {
                    if {$requiredTarget!=":" && $requiredTarget!="<-" } {
                        log.info "- Required target: $requiredTarget"
                        lappend reqTargets $requiredTarget
                    }
                }
            } 
            #dict append kiss::targets::_targets $name {*}$args
            dict lappend kiss::targets::_targets $name $reqTargets $script 
        }

        proc listTargets args {
            return [dict keys $::kiss::targets::_targets]
        }

        proc getScript target {
            set targetcontent [dict get $::kiss::targets::_targets $target]
            #log.info "Returning $target script: [lindex $targetcontent end]"
            return [lindex $targetcontent end]
        }

        ## Run Target
        proc run {target argv args} {
            set script [getScript $target]
            array set env [array get ::env]
            log.with.logger $target {
                eval $script
            }
            
            #return [dict keys $::kiss::targets::_targets]
        }

    }

    #############################
    namespace eval toolchain {

        array set tc {}

        proc register {name args} {
            array set kiss::toolchain::tc [list $name {*}$args]
        }

        proc init {name} {
            puts "INIT:  "
            set script [lindex [array get  kiss::toolchain::tc $name] 1]
            eval $script
        }
    }


    #############################
    namespace eval sources {

        array set src {}

        proc addSourceFolder {module path} {
            #set sources [lmap [kiss::utils::callIn [pwd] find $path -type f]
            set sources [lmap f [glob -nocomplain -type f -path $path **/*] { file normalize $f} ]
            puts "Found sources: $sources"
            array set kiss::sources::src [list $module $sources]
        }

        proc getSources {module} {
            return [lindex [array get kiss::sources::src $module] 1]
        }
    }

    ###############################
    namespace eval dependencies {

        set moduleDeps [dict create]

        ## Adds dependencies to the current dict
        ## The passed dependencies is a dict with format: name {lib xxx sources xxx doc xxxx}
        proc addDeps {module depsDict} {
            #dict lappend kiss::dependencies::moduleDeps $module {*}$args
            dict lappend kiss::dependencies::moduleDeps $module {*}$depsDict
        }

        proc getDeps module {
            if {[dict exists $kiss::dependencies::moduleDeps $module]} {
                return [dict get $kiss::dependencies::moduleDeps $module]
            } else {
                return {}
            }
             
        }

        proc resolveDeps {module classifier} {
            set currentDeps [getDeps $module]

            set res [lmap {name dict} $currentDeps {
                if {[dict exists $dict $classifier]} {
                    dict get $dict $classifier
                } else {
                    log.warn "No $classifier in $dict"
                    string cat ""
                }
                
            }]
            log.debug "Resolved for $module: $res"
            return $res 
        }

    }

    

    #################################
    namespace eval utils {

        proc isWindows  args {
            if {$::tcl_platform(platform)=="windows"} {
                return true 
            } else {
                return false
            } 
        }
        proc isWindows64  args {
            if {$::tcl_platform(platform)=="windows" && $::tcl_platform(machine) == "amd64"} {
                return true 
            } else {
                return false
            } 
        }

        proc isLinux  args {
            if {$::tcl_platform(platform)=="unix"} {
                return true 
            } else {
                return false
            } 
        }

        proc isLinux64  args {
            if {$::tcl_platform(platform)=="unix" && $::tcl_platform(machine) == "x86_64"} {
                return true 
            } else {
                return false
            } 
        }

        proc ::isArgv argName {
            return [uplevel [list expr \[ lsearch -exact \$argv $argName\] > -1]]
        }

        proc download {url dir} {
            exec wget -p $url -O $dir >@ stdout 2>@ stdout
        }

        ## Exec redirecting outputs to console
        proc execIn {folder args} {
            set pwd [pwd]
            file mkdir $folder
            cd $folder 
            try {
                return [exec {*}${args} >@ stdout 2>@ stdout]
            } finally {
                cd $pwd
            }
            
        }

         ## Exec redirecting outputs to console
        proc forkIn {folder args} {
            set pwd [pwd]
            file mkdir $folder
            cd $folder 
            try {
                return [exec {*}${args} >@ stdout 2>@ stdout &]
            } finally {
                cd $pwd
            }
            
        }

        ## Exec returning stdout as function result
        proc callIn {folder args} {
            set pwd [pwd]
            file mkdir $folder
            cd $folder 
            try {
                return [exec {*}${args}]
            } finally {
                cd $pwd
            }
            
        }

    }

}