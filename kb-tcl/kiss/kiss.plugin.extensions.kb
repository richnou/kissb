# SPDX-FileCopyrightText: 2024 KISSB 2024
#
# SPDX-License-Identifier: GPL-3.0-or-later

############################
## Core extension -> language
##############################

kissb.extension kissb {

    args.contains {v script {else ""} {elseScript {}}} {
        set localArgs [uplevel {set args}]
        if {[lsearch -exact $localArgs $v]!=-1} {
            uplevel [list eval $script]
        } else {
            uplevel [list eval $elseScript]
        }
    }

    args.ifContains {v script {else ""} {elseScript {}}} {
        set localArgs [uplevel {set args}]
        if {[lsearch -exact $localArgs $v]!=-1} {
            uplevel [list eval $script]
        } else {
            uplevel [list eval $elseScript]
        }
    }

    args.get {v default {to ""} {varname ""}} {
        set localArgs [uplevel {set args}]
        
        # Get default or val from args
        set __val $default
        if {[lsearch -exact $localArgs $v]!=-1} {
            set __val [lindex $localArgs [lsearch -exact $localArgs $v]+1]
        } 

        # set to requested varname
        if {$to!=""} {
            uplevel [list set $varname ${__val}]
        }
        return ${__val}
    }


    onRefresh script {
        if {[kiss::ifRefresh]} {
            uplevel [list eval $script]
        } 
    }

    withIfRefresh script {
        if {[kiss::ifRefresh]} {
            uplevel [list eval $script]
        } 
    }

    each {lst script} {
        foreach v $lst {
            uplevel [list set it $v]
            uplevel [list eval $script]
        }
    }

}

##############################
## vars extension
##############################
kissb.extension vars {

    set {name args} {
        ::kiss::vars::set $name $args
    }

    append {name args} {
        foreach v $args {
             ::kiss::vars::append $name $v
        }
       
    }

    get {name {v ""}} {
        return [::kiss::vars::get $name $v]
    }

    exists name {
        return [::kiss::vars::exists $name]
    }

    ## Module based variable resolution
    resolve {spec {default ""}} {

        # Split at . MODULE/MODULE/MODULE.VAR.VAR.VAR , and take first result
        set module [lindex [split $spec .] 0]
        set name   [join [lrange [split $spec .] 1 end] .]

        # For a module a/b/c, build search paths: a/b/c.VAR , a/b.VAR then a.VAR   (override effect)
        set i 0
        set candidates {}
        set splitModuleNames [split $module /]
        foreach splitName $splitModuleNames {
            set splitName [lindex [split $splitName .] 0]
            set candidateName [join [lrange $splitModuleNames 0 end-$i] /]
            lappend candidates $candidateName
            incr i
        }
        foreach candidate $candidates {
            #log.info "Searching for var $name in $candidate"
            if {[vars.exists ${candidate}.${name}]} {
                return [vars.get ${candidate}.${name}]
            }
        }

        if {$default==""} {
            return -error "Variable could not be resolved: $spec"
        } else {
            return $default
        }
    }
}

##############################
## env extension
##############################
kissb.extension env {

    isDefined name {
        return [expr [llength [array get ::env $name]] > 0 ? true : false]
    }
}

##############################
## Dependencies extension
##############################
kissb.extension dependencies {

    ## Save provided dict in bom
    bom dict {
        #log.info "Adding BOM: $spec"
        kiss::dependencies::addBOM $dict
    }

    add {module resolver args} {

        foreach dSpecs $args {
            foreach dSpec $dSpecs {
                log.info "Adding Dependency: $dSpec"
                kiss::dependencies::addDepSpec $module $dSpec $resolver
            }
        }

    }
}


#####################
## Asserts
#####################

kissb.extension assert {

    isFile {path msg} {
        if {![file isfile $path]} {
            error "File doesn't exist:$path , $msg"
        }
    }
}
